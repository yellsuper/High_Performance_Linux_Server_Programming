## 第9章 IO复用

IO复用使得程序能同时监听多个文件描述符，这对提高程序的性能至关重要。需要指出的是，IO复用虽然能同时监听多个文件描述符，但它本身是阻塞的。并且当多个文件描述符同时就绪时，如果不采取额外的措施，程序就只能按顺序依次处理其中的每一个文件描述符，这使得服务器程序看起来像是串行工作的。如果要实现并发，只能使用多进程或多线程等编程手段。

select系统调用的用途是：在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件。  
poll系统调用和select类似，也是在指定时间内轮询一定数量的文件描述符，以测试其中是否有就绪者。  
epoll是Linux特有的IO复用函数。它使用一组函数来完成任务，而不是单个函数。其次，epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中，从而无须像select和poll那样每次调用都要重复传入文件描述符集或事件集。但epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表。

从实现原理上来说，select和poll采用的都是轮询的方式，即每次调用都要扫描整个注册文件描述符集合，并将其中就绪的文件描述符返回给用户程序，因此它们检测就绪事件的算法的时间复杂度是O(n)。epoll\_wait则不同，它采用的是回调的方式。内核检测到就绪的文件描述符时，将触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪事件队列。内核最后在适当的时机将该就绪事件队列中的内容拷贝到用户空间。因此epoll\_wait无须轮询整个文件描述符集合来检测哪些事件已经就绪，其算法复杂度是O(1)。

## 第10章 信号

信号是由用户、系统或者进程发送给目标进程的信息，以通知目标进程某个状态的改变或系统异常。

信号是一种异步事件：信号处理函数和程序的主循环是两条不同的执行路线。很显然，信号处理函数需要尽可能快的执行完毕，以确保该信号不被屏蔽太久。一种典型的解决方案是：把信号的主要处理逻辑放到程序的主循环中，当信号处理函数被触发时，它只是简单的通知主循环程序接收到信号，并把信号值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码。信号处理函数通常使用管道来将信号“传递”给主循环：信号处理函数往管道的写端写入信号值，主循环则从管道的读端读出该信号值。需要使用IO复用系统调用来监听管道的读端文件描述符上的可读事件。如此一来，信号事件就能和其他IO事件一样被处理，即统一事件源。

## 第11章 定时器

网络程序需要处理的第三类事件是定时事件，比如定期检测一个客户连接的活动状态。服务器程序通常管理着众多定时事件，因此有效地组织这些定时事件，使之能在预期的时间点被触发且不影响服务器的主要逻辑，对于服务器的性能有着至关重要的影响。为此，我们要将每个定时事件分别封装成定时器，并使用某种容器类数据结构来串联起所有定时器。有两种高效的管理定时器的容器：时间轮和时间堆。

定时是指在一段时间之后触发某段代码的机制，我们可以在这段代码中依次处理所有到期的定时器。

## 第12章 高性能IO框架库Libevent

在处理三类事件：IO事件、信号和定时事件时，我们通常需要考虑如下三个问题：
1. 统一事件源。统一处理这三类事件既能使代码简单易懂，又能避免一些潜在的逻辑错误。
2. 可移植性。不同的操作系统具有不同的IO复用方式，比如Solaris的dev/poll文件，FreeBSD的kqueue机制，Linux的epoll系列系统调用。
3. 对并发编程的支持。在多进程和多线程环境下，我们需要考虑各执行实体如何协同处理客户连接、信号和定时器，以避免竞态条件。

IO框架库以库函数的形式，封装了较为底层的系统调用，给应用程序提供了一组更便于使用的接口。这些库函数往往比程序员自己实现的同样功能的函数更合理、更高效，且更健壮。

Libevent是开源社区的一款高性能的IO框架库，具有如下特点：
1. 跨平台支持。Libevent支持Linux、UNIX和Windows。
2. 统一事件源。Libevent对IO事件、信号和定时事件提供统一的处理。
3. 线程安全。Libevent使用libevent_pthreads库来提供线程安全支持。
4. 基于Reactor模式的实现。

Libevent的官方网站：  
http://libevent.org/
